#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/resource.h>

#include "common.h"
#include "loader.skel.h"

static int setMemoryForUserSpace(void) {
    struct rlimit newlimit = {
        .rlim_cur = RLIM_INFINITY,
        .rlim_max = RLIM_INFINITY,
    };

    if (setrlimit(RLIMIT_MEMLOCK, &newlimit)) {
        fprintf(stderr, "Error in increasing memory for userSpace app! \n");
        return 1;
    }
    return 0;
}

static int handle_event(void *ctx, void *data, size_t data_sz) {
    // void *ctx: ring_buffer__new 호출 시 전달한 Context
    // void *data: bpf_ringbuf_submit 을 통해 보낸 데이터의 시작 주소 (buffer__poll 에 의해 채워짐)
    // size_t data_sz: 전달된 데이터의 크기 (sizeof(struct event_data) 와 동일함)
    struct event_data *event = data;

    if (data_sz < sizeof(struct event_data)) {
        fprintf(stderr, "Incomplete data received.\n");
        return 1;
    }

    if (strncmp(event->exename, event->filename, MAX_FILENAME_LEN) == 0) {
        printf("Self Delete Detected\n");
        printf("--------------------\n");
        printf("PID: %d, PPID: %d, Command: %s\n", event->pid, event->ppid, event->comm);
        printf("Executable Name: %s\n", event->exename);
        printf("File is being deleted: %s\n", event->filename);
        printf("--------------------\n");
    }

    return 0;
}

int main(void) {
    if (setMemoryForUserSpace()) {
        return 1;
    }
    struct ring_buffer *rb = NULL;
    struct loader *skel = NULL;
    int err;

    skel = loader__open();
    // BPF 프로그램 Skeleton 열기.
    loader__load(skel);
    // BPF 프로그램을 커널에 로드(Insertion).
    loader__attach(skel);
    // 커널에 로드된 BPF 프로그램을, 특정 Event 에 Attach.

    rb = ring_buffer__new(bpf_map__fd(skel->maps.ringbuf_selfdel), handle_event, NULL, NULL);
    // Kernel Buffer (ringbuf) 와의 통신 채널 설정
    // bpf_map__fd(): bpf 프로그램이 생성한 버퍼의 File Descriptor 반환
    // handle_event: 콜백 함수 (BPF 버퍼에서 데이터를 읽어오면, handle_event 함수 호출하여 데이터 처리함.)
    // NULL, NULL: 각각 콜백함수의 컨텍스트 (함수로 보낼 데이터; void *ctx) 와
    //             이벤트 처리에 사용할 종료 함수(destory_func)

    if (!rb) {
        fprintf(stderr, "Failed to create ring buffer\n");
        return 1;
    }

    while(1) {
        err = ring_buffer__poll(rb, 100 /* timeout, ms */);
        // 100ms 간격으로 ringbuf 읽기
        // 읽어온 데이터를 handle_event 로 보냄
        if (err == -EINTR) { // Ctrl + C Signal 전달 시 작동 (인터럽트 무시)
            err = 0;
            break;
        }
        if (err < 0) {
            printf("Error polling perf buffer: %d\n", err);
            break;
        }
        sleep(2);
    }

    return 0;
}